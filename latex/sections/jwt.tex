\section{JWT}
\label{jwt}
JWT (JSON Web Token) is an internet standard for creating JSON based access tokens.
It asserts some number of claims in the token itself, so that authentication
protocols that uses it are completely stateless.
In other words, if i give a JWT to a completely different service it is
completely able to verify and authenticate the request, without having to access
the database.

The key concept that holds together the JWT standard is encryption, that could
be either symmetric or asymmetric.

In a zero thrust architecture, it is really rare that symmetric encryption is
used: if just one server that has access to the key is compromised, then all the
JWTs created with that key are no longer to be trusted, and must be invalidated.

For this reason the asymmetric encryption is usually preferred since only one
server has access to the signing key.

The public key is usually exposed from the same server via endpoint (see page
\pageref{jwks}).

\subsection{JWT Structure}
JWT are composed by three  parts:

\begin{enumerate}
    \item Header: a JSON object, containing information about the JWT structure
        (signing key id, JWT type, algorithm, etc.)
    \item Data: the content of the JWT itself
    \item Signature: encrypted checksum of the two sections (header and data).
\end{enumerate}

Since the first two sections are cryptographically signed, they cannot be
deliberately modified by the end user, and a third party client could easily
verify the token integrity using the public key.
\\
Therefore JWT created with an asymmetric key, can be generated by one server and
verified by everyone thanks to public keys.

\subsubsection{JWT head}
Example of JWT head:
\begin{lstlisting}
{
    "kid": "1234",
    "alg": "RSA",
    "typ": "sig",
}
\end{lstlisting}

\subsubsection{An example of JWT body:}
\begin{lstlisting}
{
    "iss": "",
    "aud": "",
    "sub": "",
}
\end{lstlisting}
\begin{itemize}
    \item \texttt{iss} : issuer, who created the JWT
    \item \texttt{aud} : audience, for who is intended the JWT.
    \item \texttt{sub} : subscriber identity, unique key that identifies the
        user
\end{itemize}

\subsubsection{the JWT signature}
The signature is simply calculated by base64 encoding the head and the body of
the JWT, and catenate them with a dot.
\begin{lstlisting}
head = json.dumps({...})
body = json.dumps({...})

payload = '.'.join([head, body])
signature = compute_hash(payload)
\end{lstlisting}

Some reserved body claims according to the specification are:

\subsubsection{Generate public Public/Private Key}
\begin{alltt}
    \$ ssh-keygen -v
    The key fingerprint is:
    SHA256:tFKUq1HLfJ3Iy6toGec804dKXPgx4P6rrL6Tc4S0wVY ale-cci@vagrant

    The key's randomart image is:
    +---[RSA 3072]----+
    |        ..       |
    |       .E        |
    |     . =++ o .   |
    |      *+=++ o    |
    |     o.*So+.     |
    |      =+oooo     |
    |       O+..o     |
    |      *+*.+ .    |
    |     o=*=*oo     |
    +----[SHA256]-----+


    \$ ssh-copy-id -i ~/.ssh/id_rsa username@host
\end{alltt}
Authorization via asymmetric cryptography. Two keys are generate a public and a secret one.
The public key is, as the name suggests, public and everyone could read it.
The client encodes his messages with the private key; the receivers could validate the authenticity of those messages using the public key.

This is one of the safest methods, but it's not viable as we need to distribute in some way the private key to
trusted users.

\subsubsection{Share the public key}
\label{jwks}
To avoid copy-pasting public keys between services, usually the authentication
server exposes them in the \texttt{.well-known/jwks.json} endpoint, using the
\href{https://tools.ietf.org/html/rfc7517#section-4}{JWK Format}.

Here is an example:

\begin{lstlisting}[language=bash]
~: curl -s http://localhost:4000/oauth/.well-known/jwks.json \
        | python -m json.tool
{
    "keys": [
        {
            "alg": "RS256",
            "e": "AQAB",
            "kid": "1",
            "kty": "RSA",
            "n": "0wMtv3UjBSWh31xs5ogySIof_HxWcdetqnkJYzsdYO_niyhgsO...",
            "use": "sig"
        }
    ]
}
\end{lstlisting}
With a quick look to the json returned by the curl response, it is obvious that
more than one key could be returned using the adopted formalism.

Each entry in the \texttt{code} array is required to have the keys:
\begin{itemize}
    \item \texttt{kty} : (key type) identifies the cryptographic family algoritm
        used with with the key. Possible values could be RSA or EC.
        The value is a case sensitive string, and MUST be present in a JWK.
    \item \texttt{use} : (public key use), identifies the intended use of the
        public key. The use is employed to indicate whether a public key is used
        for encrypting data or verifying the signature. Values defined by the
        specification are: \texttt{sig} or \texttt{enc}.
        The use is is optional, unless the application requires it.
    \item \texttt{alg} :
    \item \texttt{e} and \texttt{n}
    \item \texttt{kid} : (key id)
\end{itemize}

For more informations about the

JSON Web Keys are javascript object notation data structures that represents a
cryptographic key.

\subsection{JWE}
JWE (JSON Web Encryption) differences from the previous JWS (JSON Web
Signature), defines a way to encrypt your claims, so that only the intended
receiver could read the information presented by the token.

The main advantage that it has over JWS is the protection against MITM attacks,
since the attacker cannot see the information contained in the token unless he
has access to the encryption key.

A detailed explanation of the standard could be found
\href{https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41}{here}.
% TODO: Add specification and explain this paragraph better


