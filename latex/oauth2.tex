%!TEX program = xelatex
% rubber: set program xelatex
% vim: tw=80: colorcolumn=80: spell
\documentclass[11pt]{style}

\usepackage{alltt}
\usepackage{longtable}
\usepackage[strict]{chngpage}

\usepackage{hyperref}
\setcounter{tocdepth}{2} % Show only sections in table of contents

\title{OAuth2 \& OpenID}

\def\relator{Poggi Agostino}

\author{Corradi Alessandro}

\graphicspath{{./res/}}

\begin{document}
\maketitle{}
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

% Document sections
%[nextsection]

%==============================================================================
\section{Prelude}
\subsection{What you will find in this paper}
The goal of this document is to illustrate the OAuth2 framework and
how it can be used, by implementing a standalone micro-service.

Further down we will point out the strength and weaknesses of this protocol; when
it's best adopt this industry standard, where it's adopted and what are it's use
cases.

We will see what OpenID Connect is, the meaning of Identity Provider, Single
Sign On and what JWT is.

\subsection{Reading target}
This dissertation is suited for people who have a basic grasp on what is
authentication/authorization, and want to integrate OAuth2 with their web
server, or want to know in depth how JWT and OpenID works.

\subsection{Examples}
Alongside explanations, there will be included some code examples, written in
python.
Why python? You may ask, because i think it is arguably one of the most readable
and concise languages out there.

\section{Introduction}
In the early days everything was easier, if you wanted to grant access to your
private data to a third party application, you just have to give them your
username and password to it, and presto! The application can freely access your
account without any restrictions!

But, as we all know, there is no guarantee that an application with keep your
credentials all safe and securely stored, or even worse use them to access more
sensitive informations than necessary.

Today we have agreed to a web standard, to allow services to securely allow
access to third party applications.
This standard is a protocol that takes the name of \textbf{OAuth2}.

Often confused with API
keys\footnote{More on API keys:
\url{https://en.wikipedia.org/wiki/Application\_programming\_interface\_key}}
for their similar use and terminology, OAuth2 grants the permission to access
user data to third party application.
The protocol specifies that, instead of you handing them your credentials, an
authentication server forges a key (commonly called \textbf{access token}) that
will be used by clients to perform requests to the user data.

\subsection{Example of OAuth2 use-case}

Let's assume you go on a vacation with your friends, during that vacation you
take a lot of pictures and videos, and your friends do it too.
Each one of you uploads the pictures and videos he took on Google cloud, and
you have a shared folder that weights a few Giga.

At the end of the vacation you want to organize all the pictures and videos
automatically, by adding them labels and name them all in a consistent way, for
example using the place and the date of where the picture was created.

This sounds like a lot of work to do all by hand, but thankfully you find an
online application that does exactly what you need: by combining image
processing and the EXIF tags of each picture or video it can automatically
create labels and rename them. Neat! Now you can delegate all the work with that
application.

Conveniently that application has a button called "Access with Google drive"
that when pressed opens up the Google login page and asks you if you want to
grant access to the application.

You perform the login with Google, accept the permissions and magically the
application starts doing it's work, labeling and renaming images.

% ================================================================================
\subsection{The terminology}
What you have just read is a typical example of the OAuth2 flow, but before deep
diving into the implementation and specification of this protocol, let's clear
some terminology.

First and foremost the \textbf{resource owner}, or in other words the one who
actually owns the \textbf{protected resource} or resources.

\begin{itemize}
    \item The \textbf{protected resources}, some form of private data that is
        not publicly accessible, in the example's case the vacation's photo and
        videos.
    \item \textbf{resource owner}: the one who own the protected resource, in
        the example's case you (and your friends).
    \item \textbf{authorization server} the service that knows the resource
        owner's identity, or in other words an application where the resource
        owner has an account. In the example's case it's Google.
    \item the \textbf{client} or \textbf{third party application} is the
        applications that requires access to the private resource (photos and
        videos), or access to perform some actions on the private resource
        (rename and assign them some labels).
    \item the \textbf{resource server} is the one that has access to the private
        data, sometimes is the same as the authorization, but as we see in our
        example, it could be different.
        In the example's case it's Google drive \footnote{to be clear, Google
        has two different services: one for authorization and one for Google
        drive}.
\end{itemize}

\subsection{Authentication and Authorization}
Authorization and authentication my sound similar to one another, but they are
two distinct concepts, used in identity and access management:
authentication says who you are, authorization says what actions you can
perform.

OAuth2 is only an authorization protocol, which means that it's only use is for
granting access to protected resources to a client.

Later we could see that it could be extended and used as an authentication
provider with OpenID connect (page \pageref{openid}).

\section{OAuth2 Protocol}
OAuth2 is an authentication framework, which stands for Open Authentication.
It enables applications to obtain limited access to an HTTP service.

It works by delegating the authentication to an external server, which provides
cryptographically signed tokens, containing the authorization granted by the
user.

Since the token is signed or encrypted, the resource server, can blindly trust
the forged tokens, and checks if the required authorizations are contained in
the token.


\subsection{Abstract Protocol flow}
\begin{alltt}
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   |
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
 \end{alltt}
Above you could see the main flow of the OAuth2 protocol, the final objective is
always to obtain an access token, which could be used to perform authorized
requests.


 \begin{itemize}
     \item[(A)] The client request an authorization from the resource owner.
         The authorization request is performed directly to the resource owner,
         or preferably via the authorization server server, as intermediary.
     \item[(B)] The client receives an authorization grant, which is a
         credential representing the resource owner's authorization, expressed
         using one of four grant types defined in the specification or using an
         extension grant type.
     \item[(C)] The client requests the access token, by authenticating with the
         authorization server and presenting the received authorization grant.
     \item[(D)] The authorization server authenticates the client and validates
         the received authorization grant, if valid the access token is
         returned.
     \item[(E)] the client requests the protected resource from the resource
         server providing the access token.
     \item[(F)] the resource server validates the access token. If valid the
         requested resource is provided at the client.
 \end{itemize}

\subsection{Different grants for different clients}
% TODO: expose better
The specification differs between public and confidential client.

\subsection{Different grant type}
The specification supports different ways of obtaining the access token, called
\textbf{grant types}.
\begin{enumerate}
    \item access code
    \item implicit
    \item client credentials
    \item client password
\end{enumerate}

\subsection{Access Token}
Access tokens are in any shape or form, credentials, that client application use
to access resources protected by resource servers.
\\
They take the form of a string, that usually (but not always) the client cannot
interpret.

Each access token is unique, and resource servers could verify the validity and
look up the scopes, granted by the resource owner to the access token.

The OAuth2 specification does not constrain the access token format, saying
that, quote: \\
\textit{``Access tokens can have different formats, structures, and methods of
utilization''}.

As we will see later, the OpenID Connect framework takes advantage of this
freedom, by imposing a strict token format (see JWT at page \pageref{jwt}).

\subsection{Refresh token}
\begin{alltt}
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+
\end{alltt}

Refresh tokens are credentials used to obtain access tokens. Refresh tokens are
issued to the client by the authorization server and are used to obtain a new
access token when the current access token becomes invalid or expires, or to
obtain an additional access token identical or narrower scope.

Issuing a refresh token is completely optional, at the desecration of the
authorization server.
If the authorization server issues an access token, it is included with the
access token (Step B).

The value of the refresh token is usually a string opaque to the client, unlike
access token, it is only intended to be used by the authorization server,
therefore this kind of token is not sent to the resource server when accessing
protected resources.


The protocol is heavily dependent on HTTPS and HTTP redirects.

Before initiating the protocol, the client registers with the authorization
server.
The means through which the client registers are beyond the scope of the
specification, but typically involve end-user interaction with an HTML
registration form.

In the client registration, it is required to specify:
\begin{itemize}
    \item the client type
    \item it client redirection(s)
    \item include any other information required by the authorization server,
        for example the application name, logo website, description and others.
\end{itemize}

It starts with a specifically crafted URL, when the client needs the access to
the protected resource, it redirects the user to that URL.

The URL contains a query string
It starts with a specifically crafted redirect URL, that the clients
redirects the user to.
The URL points to the authorization's server, and it contains parameters in the
form of a query string. Here is an example:

\begin{lstlisting}
import urllib.request

callback_url = urllib.request.quote('http://localhost:8080')
client_id = 'YOUR-CLIENT-ID-HERE'

querystring = urlencode({
    'redirect_uri': callback_url,
    'client_id':    client_id,
    'grant_type':   'code'
})

redirect_to = f'https://www.googleapis.com?{querystring}'
\end{lstlisting}


Authorization and resource servers could be a third party service trusted by the
resource server.

\begin{itemize}
    \item  redirect uri, where the client will be redirect after authorization.
    \item  response type: type of the information the client expects to receive
        (most common code, (authorization code))
    \item  scope: permission that the client wants
    \item  consent: authorization server takes the scopes and verifies whether or not
        it want to give client permissions
    \item  client\_id: used to identify the client with the authorization server
    \item  client\_secret: secret password that only client and authorization server knows
    \item  \texttt{auth\_code}: short lived code that server sends to the client
    \item access\_token: key the client will use to communicate with the resource server.
\end{itemize}

\subsection{The protocol}
It all starts with a specifically crafted URL:
\begin{lstlisting}
https://www.googleapis.com
    ?redirect_uri=http://localhost:3030
    &client_id=
    &scope=email read-contacts
    &grant=code
\end{lstlisting}

In the login prompt, users sees the assertion that will be inserted in the
OAuth2 JWT.

OAuth2 flow is always between website A and B, the user has only to consent the
OAuth2 request.

It all starts with a specially crafted URL, besides the host, it includes extra
information that says what the host should do, they include the registered
application, the redirect uri (once discord is done the authorization the host
will send you there). Response type is for saying that you want a code back, and
scope is the actual data that you want to access.


\subsubsection{OAuth2}
Provide an access token at each client, which they could use to validate their
identity at each API request.  This token could be either valid, expired,
revoked or invalid.

\subsubsection{Small digression on API Key}
\begin{lstlisting}[language=bash]
$ curl --header 'Authorization: Apikey 1234567890abcdef'
\end{lstlisting}
API keys make sense when the users of an API are only developers.


\begin{lstlisting}[language=bash]
$ curl -v --header "Authorization: Bearer $ACCESS_TOKEN" \
    http://localhost:8080/api

> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.72.0
> Accept: */*
> Authorization: Bearer ...
\end{lstlisting}

The OAuth2 protocol provides a secure and standardized way for creating and exchanging those token between client and server.


%==============================================================================
\section{OAuth2: authorization code}
\begin{alltt}
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)

 \end{alltt}
Note: The lines illustrating steps (A), (B), and (C) are broken into
two parts as they pass through the user-agent.


The authorization code grant type is used to obtain both access and refresh
tokens, and is optimized for confidential clients.
Since it is a redirection-based flow, the clients must be capable of interacting
with the resource owner's user-agent, and capable of receiving incoming requests
(via redirection) from the authorization server.

\subsection{Steps required to obtain the access token}
% NOTE: re-read and explain in more human words this
\begin{enumerate}
    \item[(A)] the client redirects the resource owner's user agent to the
        authorization endpoint, and provides the client identifier, request
        scope state and redirection URI, to which the authorization server will
        send the user agent back, once the access is granted (or denied).
    \item[(B)] the authorization server authenticates the resource owner (via
        user agent) and asks the resource owner to allow or deny, the client's
        access request.
    \item[(C)] Assuming the resource's access is granted, the authorization
        server redirects the user-agent back to the client using the redirection
        URI provided earlier.
    \item[(D)] The client exchanges the received authorization code, client id,
        client secret and once again the redirection uri for the authorization code.

    \item[(E)] the authorization server authenticates the client, validates the
        authorization code, and ensures that the redirection URI received
        matches the URI used to redirect the client in step (C). If valid, the
        authorization server responds back with an access token and,
        optionally a refresh token.
\end{enumerate}

\begin{enumerate}
    \item
        Redirect to the authorization provider.
        \begin{alltt}
    http://google.apis.com?response_type=code\&client_id...
        \end{alltt}

    \item
        If the authorization is successful, the OAuth2 server will redirect to
        \lstinline{redirect\_uri} passing a \lstinline{code}
        as GET parameter. Otherwise \lstinline{error} contains the reason why the authorization was not successful.
        \begin{alltt}
    POST /oauth/token HTTP/1.1
    Host: authorization-server.com

    grant_type=authorization_code
    &code=xxxxxxxxxxx
    &redirect_uri=https://example-app.com/redirect
    &client_id=xxxxxxxxxx
    &client_secret=xxxxxxxxxx
        \end{alltt}

        \textit{If an authorization code is used more than once, the authorization server must deny the subsequent request.}

    \item
        The client exchanges the \lstinline{code}, called also "grant token", with the server to obtain an
        \\
        \lstinline{access\_token}.
    \item The server returns the access token with additional informations, such
        as expire date and JWT.
    \item
        The client uses the access token for APIs requests.
\end{enumerate}

\subsection{Revoke an access token}
By requirements, an OAuth2 authentication server must expose an endpoint for
revoking the validity of a particular token.

In case the authentication is performed via JWT (see page \pageref{jwt})
Something something

\section{OAuth2: implicit flow}
Since public clients could not store a "client secret" to exchange for an
authorization code, the protocol is slightly altered.
Instead of returning the authorization code, the access token is returned
directly in the GET parameters of the redirect.

Therefore the steps required to perform the authorization are reduced to 3:
\begin{enumerate}
    \item Redirect to the authorization provider
    \item User performs the authentication and approves the requested
        permissions
    \item The access token is returned to the third party client.
\end{enumerate}

\begin{alltt}
     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier     +---------------+
     |         -+----(A)-- & Redirection URI --->|               |
     |  User-   |                                | Authorization |
     |  Agent  -|----(B)-- User authenticates -->|     Server    |
     |          |                                |               |
     |          |<---(C)--- Redirection URI ----<|               |
     |          |          with Access Token     +---------------+
     |          |            in Fragment
     |          |                                +---------------+
     |          |----(D)--- Redirection URI ---->|   Web-Hosted  |
     |          |          without Fragment      |     Client    |
     |          |                                |    Resource   |
     |     (F)  |<---(E)------- Script ---------<|               |
     |          |                                +---------------+
     +-|--------+
       |    |
      (A)  (G) Access Token
       |    |
       ^    v
     +---------+
     |         |
     |  Client |
     |         |
     +---------+
\end{alltt}


This protocol is a bit "faster" than the other one (if you want to define it
like that), because it skips the intermediate step to exchange code with access
token.

But it is clear that if an external application (like a chrome extension) reads
your "\texttt{window.location}", you are basically done, and the innocent chrome
extension could perform OAuth2 requests with your account, without you having to
give it the permissions!

A solution to this problem is discussed later in this dissertation at the PKCE
section (pg. \pageref{pkce})

It is advised to remove the access token from the URL once you have read it, to
minimize the possibility to leak it.

\subsection{Two channel communications: trusted and insecure}
There are no perfectly secured channels in the real world, but there are at
best, only ways to make a less secure channel more secure.

In the standard flow of the OAuth2 protocol (grant code), two channels are
involved:
\begin{itemize}
    \item a front-end channel, used for redirect and a first exchange of client
        id with an authorization code
    \item a back-end channel, used for exchanging the code received from the
        less trusted channel with the authorization provider
\end{itemize}

The "back-end channel" takes the name of "trusted channel". On the other hand,
the fronted takes the names of "insecure channels", because it's easily tampered
and overheard.

%==============================================================================
\section{OAuth2: client credentials}
\begin{alltt}
     +---------+                                  +---------------+
     |         |                                  |               |
     |         |>--(A)- Client Authentication --->| Authorization |
     | Client  |                                  |     Server    |
     |         |<--(B)---- Access Token ---------<|               |
     |         |                                  |               |
     +---------+                                  +---------------+
\end{alltt}
The client credentials flow is intended for server-side (confidential) client
applications, with no end user, which normally describes machine to machine
communication.

The client ID and secret are sent base64 encoded, using the http basic
auth protocol.

Since the client authentication is used, no additional authorization is needed.

\begin{lstlisting}
     POST /token HTTP/1.1
     Host: server.example.com
     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
     Content-Type: application/x-www-form-urlencoded

     grant_type=client_credentials
     &scope=customScope
\end{lstlisting}

On successful response, the application receives tan access token:
\begin{lstlisting}
{
    "access_token": "eyJhbG[...]1LQ",
    "token_type": "Bearer",
    "expires_in": 3600,
    "scope": "customScope"
}
\end{lstlisting}

\section{OAuth2: grant type password}
This grant type is one of the simples grants, involving only one step: the
application presents a traditional username and password login form to collect
the user's credentials and make a POST request to the server to exchange the
password for an access token.

\begin{alltt}
POST /oauth/token HTTP/1.1
Host: authorization-server.com
Content-type: application/x-www-form-urlencoded

grant_type=password
&username=exampleuser
&password=1234luggage
&client_id=xxxxxxxxxx
\end{alltt}

The server replies with an access token, in the same format as the other grant
types.

\begin{lstlisting}
{
  "access_token": "MTQ0NjOkZmQ5OTM5NDE9ZTZjNGZmZjI3",
  "token_type": "bearer",
  "expires_in": 3600,
  "scope": "create"
}
\end{lstlisting}
\subsection{When the password grant type is used?}
Since this grant type requires to collect the user's password, this is the exact
problem that OAuth was created to avoid in the first place, so why was it
included as part of OAuth in first place?

While a service should never let a third party app use the password grant, it is
reasonable for a service's own application to ask the user to enter their
password.
For example, if you download Twitter's mobile app, you would not be surprised if
the first thing it does when launched is ask for you Twitter password.
On the other hand if you download a third-party Gmail application, it should use
Google's OAuth server rather than ask you to enter your Gmail password.

This grant type let's the application take advantage of the rest of benefits
that OAuth provides around access tokens and token lifetimes.
The user's password instead of being stored on the device, is exchanged with the
access token.

\section{OpenID connect}
\label{openid}
OAuth2.0 is designed only for granting authorization to third party applications
to the resource server. Nothing more and nothing less.

To make an example, OAuth2 is like giving an application a key, that does not
tell anything about the owner's identity.

OpenID Connect (OIDC) is a thin layer that sits on top of OAuth2.0 that add functionality around
login and profile information about the person who is logged in.
Instead of a key, OpenID is like giving a person a badge. A badge not only gives
permission but also some basic information of who your are.

The OpenID requests in the OAuth2 protocol are easily recognizable by the
'openid' included in the scope list.

OIDC establish a client to perform a login session.
When an authorization server supports OIDC it referred as an identity provider,
since it provides information about the resource owner back to the client.

OpenID connect, enables scenarios where one login can be shared among multiple
applications. It is also known as single sign on.
For example an application can support single-sign-on (SSO) with social networking services (i.e.
Facebook or Twitter) so that a user can use a login that he already has and it's
comfortable using it.

Example with ATM. ATM is the client and it communicates with the bank. The bank
card is the token issued by the bank. Not only gives access to the ATM to your
bank account, but holds some basic information about you, when the card expires
and why you are.
ATM cannot work without the infrastructure of the bank.

On top of OAuth2, a specific scope of OpenID is used. The authorization server
goes to all the steps listed before and issues the client an authorization code
via the client's browser.
The key difference is that the client receives both an access token and an id
token.

ID token is a specifically formatted token (JWT). Client can extract your user
id, your email, when you logged in, when it expires, and it can tell if anyone
has tried to tamper with the JWT.

Fields contained in the JWT are called claims.
There is also a standard way that a client can ask additional information from the
authorization server, such as the email address.

The full list of OpenID Connect specification reserved scopes is reported at
page \pageref{openid}.

\subsection{the /userinfo endpoint}
OpenID specification defines a protected OAuth2 endpoint, that returns
additional informations (claims) about the authenticated end-user.
To obtain the requested claims, the client makes a request to the userinfo
endpoint, using an access token obtained through OpenID Connect
Authentication.

The response claims are normally represented by a JSON objet that contains a
collection of name and value pair of each claim.

If the UserInfo response is signed and/or encrypted, then the claims are
returned in a JWT and the content-type MUST be \texttt{application/jwt}.
The response may also be encrypted without being signed.


%==============================================================================
\section{JWT}
\label{jwt}
JWT (JSON Web Token) is an internet standard for creating JSON based access tokens.
It asserts some number of claims in the token itself, so that authentication
protocols that uses it are completely stateless.
In other words, if i give a JWT to a completely different service it is
completely able to verify and authenticate the request, without having to access
the database.

The key concept that holds together the JWT standard is encryption, that could
be either symmetric or asymmetric.

In a zero thrust architecture, it is really rare that symmetric encryption is
used: if just one server that has access to the key is compromised, then all the
JWTs created with that key are no longer to be trusted, and must be invalidated.

For this reason the asymmetric encryption is usually preferred since only one
server has access to the signing key.

The public key is usually exposed from the same server via endpoint (see page
\pageref{jwks}).

\subsection{JWT Structure}
JWT are composed by three  parts:

\begin{enumerate}
    \item Header: a JSON object, containing information about the JWT structure
        (signing key id, JWT type, algorithm, etc.)
    \item Data: the content of the JWT itself
    \item Signature: encrypted checksum of the two sections (header and data).
\end{enumerate}

Since the first two sections are cryptographically signed, they cannot be
deliberately modified by the end user, and a third party client could easily
verify the token integrity using the public key.
\\
Therefore JWT created with an asymmetric key, can be generated by one server and
verified by everyone thanks to public keys.

\subsubsection{JWT head}
Example of JWT head:
\begin{lstlisting}
{
    "kid": "1234",
    "alg": "RSA",
    "typ": "sig",
}
\end{lstlisting}

\subsubsection{An example of JWT body:}
\begin{lstlisting}
{
    "iss": "",
    "aud": "",
    "sub": "",
}
\end{lstlisting}
\begin{itemize}
    \item \texttt{iss} : issuer, who created the JWT
    \item \texttt{aud} : audience, for who is intended the JWT.
    \item \texttt{sub} : subscriber identity, unique key that identifies the
        user
\end{itemize}

\subsubsection{the JWT signature}
The signature is simply calculated by base64 encoding the head and the body of
the JWT, and catenate them with a dot.
\begin{lstlisting}
head = json.dumps({...})
body = json.dumps({...})

payload = '.'.join([head, body])
signature = compute_hash(payload)
\end{lstlisting}

Some reserved body claims according to the specification are:

\subsubsection{Generate public Public/Private Key}
\begin{alltt}
    \$ ssh-keygen -v
    The key fingerprint is:
    SHA256:tFKUq1HLfJ3Iy6toGec804dKXPgx4P6rrL6Tc4S0wVY ale-cci@vagrant

    The key's randomart image is:
    +---[RSA 3072]----+
    |        ..       |
    |       .E        |
    |     . =++ o .   |
    |      *+=++ o    |
    |     o.*So+.     |
    |      =+oooo     |
    |       O+..o     |
    |      *+*.+ .    |
    |     o=*=*oo     |
    +----[SHA256]-----+


    \$ ssh-copy-id -i ~/.ssh/id_rsa username@host
\end{alltt}
Authorization via asymmetric cryptography. Two keys are generate a public and a secret one.
The public key is, as the name suggests, public and everyone could read it.
The client encodes his messages with the private key; the receivers could validate the authenticity of those messages using the public key.

This is one of the safest methods, but it's not viable as we need to distribute in some way the private key to
trusted users.

\subsubsection{Share the public key}
\label{jwks}
To avoid copy-pasting public keys between services, usually the authentication
server exposes them in the \texttt{.well-known/jwks.json} endpoint, using the
\href{https://tools.ietf.org/html/rfc7517#section-4}{JWK Format}.

Here is an example:

\begin{lstlisting}[language=bash]
~: curl -s http://localhost:4000/oauth/.well-known/jwks.json \
        | python -m json.tool
{
    "keys": [
        {
            "alg": "RS256",
            "e": "AQAB",
            "kid": "1",
            "kty": "RSA",
            "n": "0wMtv3UjBSWh31xs5ogySIof_HxWcdetqnkJYzsdYO_niyhgsO...",
            "use": "sig"
        }
    ]
}
\end{lstlisting}
With a quick look to the json returned by the curl response, it is obvious that
more than one key could be returned using the adopted formalism.

Each entry in the \texttt{code} array is required to have the keys:
\begin{itemize}
    \item \texttt{kty} : (key type) identifies the cryptographic family algoritm
        used with with the key. Possible values could be RSA or EC.
        The value is a case sensitive string, and MUST be present in a JWK.
    \item \texttt{use} : (public key use), identifies the intended use of the
        public key. The use is employed to indicate whether a public key is used
        for encrypting data or verifying the signature. Values defined by the
        specification are: \texttt{sig} or \texttt{enc}.
        The use is is optional, unless the application requires it.
    \item \texttt{alg} :
    \item \texttt{e} and \texttt{n}
    \item \texttt{kid} : (key id)
\end{itemize}

For more informations about the

JSON Web Keys are javascript object notation data structures that represents a
cryptographic key.

\subsection{JWE}
JWE (JSON Web Encryption) differences from the previous JWS (JSON Web
Signature), defines a way to encrypt your claims, so that only the intended
receiver could read the information presented by the token.

The main advantage that it has over JWS is the protection against MITM attacks,
since the attacker cannot see the information contained in the token unless he
has access to the encryption key.

A detailed explanation of the standard could be found
\href{https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41}{here}.
% TODO: Add specification and explain this paragraph better


\section{Access tokens}
Since we are able to trust JWTs  without the use of a database, they offer the
main advantage to not issue database calls to verify the user identity.


Using JWTs instead of cookies for authentications grants the main advantage to
not issue a database, but as they sail "with great power comes great
responsibility", in fact if the token is stolen by someone, you cannot do
anything about it.

Since it is a completely stateless protocol, using JWT as is, there is no way
you can revoke access to the token. No database calls means that there is
nowhere to store that JWT is been revoked.

It is true that it is not easy to steal them, because OAuth2 protocol specifies
that all interactions between client and server are made using SSL protocol, but
it is not impossible.

One workaround to this problem is to make JWTs expire in a short lapse of time,
usually 15 minutes to an hour, then force clients either to re-authenticate or
provide them an extra token (\textit{refresh\_token}), used to re-claim
authentication on their behalf.

Refresh tokens are exactly like session: JWTs stored in the database, with a
long or usually without expiry date.
They should securely stored, in order to prevent XSS and CSRF attacks.

Even with refresh token we have the big advantage to query the database
approximately once each 15 minutes per user.

With that said, it still lies the problem that there is no easy way to revoke a
token. Even if a refresh token is deleted from the database, it's corrispettive
access token is still usable until expiry.

\subsection{Example of access token}
The following whitespaces between the access token sections are been introduced
only to simplify the readability.
It is important to say that Whitespaces characters are not allowed inside an
access token.

\begin{lstlisting}
eyJhbGciOiAiUlMyNTYiLCAia2lkIjogIjEiLCAidHlwIjogIkpXVCJ9.

eyJhdXRocyI6ICIiLCAiaXNzIjogImh0dHBzOi8vbG9jYWxob3N0OjgwMDAiLCAic3V
iIjogMiwgImlhdCI6IDE2MTQzNzI0MzUuMDM4MTg4NywgImV4cCI6IDE2MTQzNzYwMz
UuMDM4MTg4N30.

slCAkhLRu9w-rBhmLUh487UPrqkJF1cBpXE5LyWRR1KH1XcPA_QW_uen06p7eHI
GNKs6zSttlz0metnTjyuPFtkuU7I9Tu1djF2b5qVxOjbeDjGr_7ESuJZakKa7ljMloR
bEW65FRpTGllIPBmFOqp8VXlM1h30ogT_Mm-zl1DoSUcIIhrDT3qFEGvRz3nw049g2R
0hkTPrQK-J4bkG-7vf9f9H_PKOel2l2JtKk-3kZ-l8JNKpqM29BVpTRJzmuxNsZMwVP
JJtt-hqBinTFJ15YHwKf_hKT3bjybibmm2ciXjFHvK3p4HREdXwvsR7A4la4dto4FCt
V09IG1L9eF0kyjFkLdu2Unz7kf2YFz4fHvU7KPizJt3hPJASi_l8HJoBd1Y7sTPsjxf
IUycjgGp0yc7qwGl9ZuQmDXZ3dMj4VpBIEKGNMVbwU8IzInIFuC9R-NpqI961YCWxJ0
Qnly5rrHtw3EJy9GjW8u5cJkY7w0lJCbpvfULMqNpznSXKC0WaoictP7d80CKc9LwER
cyZY8kg4PMbZGhc2VHdEyGL4r1xZDqxZhdAYFMXRSs4DVJk5GkISyBmo2kE0rR3QYTA
NIuB80vbjuN9IzX6TTEPfFbvPdFd7oTrmN_xhR_uMu0Omv8f0o0bvXDeYRg1fL6AWFa
BOYO1qWCdTxj7r8as
\end{lstlisting}

\subsubsection{Head}
\begin{lstlisting}
eyJhbGciOiAiUlMyNTYiLCAia2lkIjogIjEiLCAidHlwIjogIkpXVCJ9.
\end{lstlisting}
\begin{lstlisting}
{"alg": "RS256", "kid": "1", "typ": "JWT"}
\end{lstlisting}

In the header is contained the information that explains how the JWT has been
created: the algorithm (\texttt{alg}), the type and the id of the encryption key
used (\texttt{kid}).
\\
If the JWT is of type JWS (it has a signature), usually the \texttt{kid} refers
to a public key, expsed in the jwks endpoint (more at page \pageref{jwks}).

\subsubsection{Body}
\begin{lstlisting}
eyJhdXRocyI6ICIiLCAiaXNzIjogImh0dHBzOi8vbG9jYWxob3N0OjgwMDAiLCAic3V
iIjogMiwgImlhdCI6IDE2MTQzNzI0MzUuMDM4MTg4NywgImV4cCI6IDE2MTQzNzYwMz
UuMDM4MTg4N30.
\end{lstlisting}
\begin{lstlisting}
{
    "auths": "",
    "iss": "https://localhost:8000",
    "sub": 2,
    "iat": 1614372435.0381887,
    "exp": 1614376035.0381887
}
\end{lstlisting}

OpenID specification describes these extra fields, required in the JWT body:
\begin{itemize}
    \item \texttt{sub}: subscriber identity, an unique identifier of the user in
        the authorization server.
    \item \texttt{iat} issued at, unix timestamp describing when the JWT has
        been created.
    \item \texttt{exp} expiry date of the JWT, expressed in unix timestamp.
    \item \texttt{auths} is an example of custom field inserted from the authorization
        provider
\end{itemize}

The full list of OpenID reserved claims could be found at page \pageref{openid}.

\subsubsection{Signature}
\begin{lstlisting}
slCAkhLRu9w-rBhmLUh487UPrqkJF1cBpXE5LyWRR1KH1XcPA_QW_uen06p7eHI
GNKs6zSttlz0metnTjyuPFtkuU7I9Tu1djF2b5qVxOjbeDjGr_7ESuJZakKa7ljMloR
bEW65FRpTGllIPBmFOqp8VXlM1h30ogT_Mm-zl1DoSUcIIhrDT3qFEGvRz3nw049g2R
0hkTPrQK-J4bkG-7vf9f9H_PKOel2l2JtKk-3kZ-l8JNKpqM29BVpTRJzmuxNsZMwVP
JJtt-hqBinTFJ15YHwKf_hKT3bjybibmm2ciXjFHvK3p4HREdXwvsR7A4la4dto4FCt
V09IG1L9eF0kyjFkLdu2Unz7kf2YFz4fHvU7KPizJt3hPJASi_l8HJoBd1Y7sTPsjxf
IUycjgGp0yc7qwGl9ZuQmDXZ3dMj4VpBIEKGNMVbwU8IzInIFuC9R-NpqI961YCWxJ0
Qnly5rrHtw3EJy9GjW8u5cJkY7w0lJCbpvfULMqNpznSXKC0WaoictP7d80CKc9LwER
cyZY8kg4PMbZGhc2VHdEyGL4r1xZDqxZhdAYFMXRSs4DVJk5GkISyBmo2kE0rR3QYTA
NIuB80vbjuN9IzX6TTEPfFbvPdFd7oTrmN_xhR_uMu0Omv8f0o0bvXDeYRg1fL6AWFa
BOYO1qWCdTxj7r8as
\end{lstlisting}

\begin{lstlisting}
# Signature verification
\end{lstlisting}

\subsection{Access tokens in openid}
TODO: Access token in openid example

\subsection{Pros and Cons of JWTs}
\subsubsection{Pros:}
\begin{itemize}
    \item Stateless
    \item great for api
    \item secure
    \item carry useful and trusted information
    \item can store information that can drive UX without backend interaction.
    \item No need for a centralized database.
\end{itemize}
\subsubsection{Cons:}
\begin{itemize}
    \item sharing secrets in a microservice architecture.
    \item Key management: where to put public key; how to kow if it's valid and
        deprecated keys.
    \item very tricky to consume correctly
    \item careful storage of refresh token
    \item Impossibility to revoke tokens
    \item Insecure implementation libraries (no algorithm)
\end{itemize}

%==============================================================================
\section{Protocol Vulnerabilities}
\subsection{PKCE (Proof Key for Code Exchange)}
\label{pkce}
Public applications, such as desktop and mobile apps, are unable to securely
store credentials, in our case, the client secret.

For this particular reason the implicit flow has been created, so
that the step after the authorization that exchanges the code and the secret
with the authorization code is skipped, so the authorization code is immediately
returned.

This particular sequence of events opens up a vulnerability:
when the access token is returned by the authorization response, malicious apps
running alongside our OAuth2 client are able to read it, and therefore use it as
our application would.

For example, if your client is running in a browser, let's say firefox just to
pick one, any plugin you have installed has access to the current url, and
therefore to the access\_token.

PKCE is a superset feature for OAuth2, idealized for preventing this kind of
attack, called "authorization code interception".

OAuth2.1 specification will mandate that all implementation of the authorization
grant type use PKCE.

\begin{enumerate}
    \item the client generates a random string, and calculates the hash using a
        hashing function
    \item the client performs the normal oauth2 flow, providing along with the
        client secret, the random string hashed value.
    \item when the authorization server performs a successful redirect with the
        'code', the client exchanges with a post request, the code and the
        unhashed secret with the access token.
\end{enumerate}

This feature blocks "easy" oauth2 attacks, that could be performed simply by
reading the access token from the GET request.


\section{OpenID Reserved claims}
{
    \setlength\LTleft{-1cm}%
    \setlength\LTright{-1in}%
    \begin{longtable}{||l|l|}
        \hline
        Claim Name             & Claim Description \\
        \hline
        \hline
        iss                  & Issuer \\
        sub                      & Subject \\
        aud                      & Audience \\
        exp                      & Expiration Time \\
        nbf                      & Not Before \\
        iat                      & Issued At \\
        jti                      & JWT ID \\
        name                     & Full name\\
        given\_name                & Given name(s) or first name(s)\\
        family\_name               & Surname(s) or last name(s)\\
        middle\_name               & Middle name(s)\\
        nickname                  & Casual name Shorthand name by which the End-User wishes to be referred to\\
        preferred\_username        & Same as 'nickname'\\
        profile                   & Profile page URL\\
        picture                   & Profile picture URL\\
        website                   & Web page or blog URL\\
        email                     & Preferred e-mail address\\
        email\_verified            & True if the e-mail address has been verified; otherwise false\\
        gender                    & Gender\\
        birthdate                 & Birthday\\
        zoneinfo                  & Time zone\\
        locale                    & Locale\\
        phone\_number              & Preferred telephone number True if the phone number has\\
        phone\_number\_verified     & been verified; otherwise false\\
        address                   & Preferred postal address\\
        updated\_at                & Time the information was last updated\\
        azp                       & Authorized party - the party to which the ID Token was issued\\
        nonce                     & Value used to associate a Client session with an ID Token\\
        auth\_time                 & Time when the authentication occurred\\
        at\_hash                   & Access Token hash value\\
        c\_hash                    & Code hash value\\
        acr                       & Authentication Context Class Reference\\
        amr                       & Authentication Methods References\\
        sub\_jwk                   & Public key used to check the signature of an ID Token\\
        cnf                       & Confirmation\\
        sip\_from\_tag              & SIP From tag header field parameter value\\
        sip\_date                  & SIP Date header field value\\
        sip\_callid                & SIP Call-Id header field value\\
        sip\_cseq\_num              & SIP CSeq numeric header field parameter value\\
        sip\_via\_branch            & SIP Via branch header field parameter value\\
        orig                      & Originating Identity String\\
        dest                      & Destination Identity String\\
        mky                       & Media Key Fingerprint String\\
        events                    & Security Events\\
        toe                       & Time of Event\\
        txn                       & Transaction Identifier\\
        rph                       & Resource Priority Header Authorization\\
        sid                       & Session ID\\
        vot                       & Vector of Trust value\\
        vtm                       & Vector of Trust trustmark URL\\
        attest                    & Attestation level as defined in SHAKEN framework\\
        origid                    & Originating Identifier as defined in SHAKEN framework\\
        act                       & Actor\\
        scope                     & Scope Values\\
        client\_id                 & Client Identifier Authorized Actor - the party\\
        may\_act                   & that is authorized to become the actor\\
        jcard                     & jCard data\\
        at\_use\_nbr                & Number of API requests for which the access token can be used\\
        div                       & Diverted Target of a Call\\
        opt                       & Original PASSporT (in Full Form)\\
        vc                        & Verifiable Credential as specified in the W3C Recommendation\\
        vp                        & Verifiable Presentation as specified in the W3C Recommendation\\
        \hline
    \end{longtable}
}

This table comes from \url{https://www.iana.org/assignments/jwt/jwt.xhtml},
there you could find when and by which specification each reserved field was
introduced.

\restoregeometry

\section{Dissertation Acknowledgments}
\begin{itemize}
    \item CED MaxMara
\end{itemize}

\begin{thebibliography}{9}
    \bibitem{google api dev}
    Using OAuth 2.0 to Access Gooogle APIs
    \\
    \url{https://developers.google.com/identity/protocols/oauth2}

    \bibitem{Api Keys vs Oauth}
    API Keys vs OAuth Tokens vs JSON Web Tokens
    \\
    \url{https://zapier.com/engineering/apikey-oauth-jwt/}

    \bibitem{okta}
    The OAuth2 password grant
    \\
    \url{https://developer.okta.com/blog/2018/06/29/what-is-the-oauth2-password-grant}

    \bibitem{tools.ietf.org}
    The OAuth2 standard (tools.ietf.org)
    \url{https://tools.ietf.org/html/rfc6749#section-2.3.1}
\end{thebibliography}

\newpage
\end{document}
