%!TEX program = xelatex
% vim: tw=80: colorcolumn=80: spell
\documentclass{style}

\usepackage{alltt}

\setcounter{tocdepth}{2} % Show only sections in table of contents

\title{OAuth2}

\def\relator{Poggi Agostino}

\author{Corradi Alessandro}

\graphicspath{{./res/}}

\begin{document}
\maketitle{}
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

% Document sections
%[nextsection]

%==============================================================================
\section{Prelude}
\subsection{What is this report?}
\subsection{Who wrote this report?}
\subsection{What are the goals of this document?}

\section{Introduction}

\subsection{The problem}
Leave this after rather than before, (include an hook at the beginning of the
introduction)

Just imagine a website that it's main functionality is manage the warehouse of a
large number of products.
The functionalities available could be numerous, here are a few:

\begin{itemize}
    \item retrieve the list of products in the warehouse
    \item Add or remove a product
    \item Register a shipment
    \item Create the list of barcode for a shipment
\end{itemize}



Let's imagine that we have a server that manages a vast list of products. Those
products could be searched, filtered and sorted by different fields, like the
name, color, insertion date and so on.  The search query is submitted, the
server returns a web page with the products, represented in a tabular fashion.

The server becomes popular and is used by million of users, and you start to
think that sharing those search results could be a cool feature.

We want to use third party API to integrate this feture.
% Necessity of communication between client and server.

Different ways to achieve the goal, here are a few of them:
\subsubsection{Direct transmission of the user identifier}
Directly send the user id to the server
\begin{alltt}
    \$ curl -v -X POST http://localhost:8080/db_auth '\{"user-id": 1\}'
\end{alltt}
I do not want to sped too much time on this one. It is for sure one of the
fastest
and less secure way to communicate the user identity.

Even someone with some basic knowledge of programming could recognize that by changing the
value of \texttt{user-id}, the request would still be valid and you are recognized as
another user.

\subsubsection{Http Basic Authentication}
Http Basic Auth: each API request is signed with a username and a passwrod, encoded in base64
\begin{alltt}
    \$ curl -u Aladdin:OpenSesamus -v http://localhost:8080/basic

    > GET / HTTP/1.1
    > Host: localhost:8080
    > Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW11cw==
    > User-Agent: curl/7.72.0
    > Accept: */*
    ...
\end{alltt}
Since the credentials are neither hashed nor encrypted, your username and password are always visible by
someone who could read the headers.
Therefore this protocol requires an https channel in order to be somewhat secure.

\subsubsection{API Key}
\begin{alltt}
    \$ curl --header Authorization: Apikey 1234567890abcdef
\end{alltt}
API keys make sense when the users of an API are only developers.

\subsubsection{Public/Private Key}
\begin{alltt}
    \$ ssh-keygen -v
    The key fingerprint is:
    SHA256:tFKUq1HLfJ3Iy6toGec804dKXPgx4P6rrL6Tc4S0wVY ale-cci@vagrant

    The key's randomart image is:
    +---[RSA 3072]----+
    |        ..       |
    |       .E        |
    |     . =++ o .   |
    |      *+=++ o    |
    |     o.*So+.     |
    |      =+oooo     |
    |       O+..o     |
    |      *+*.+ .    |
    |     o=*=*oo     |
    +----[SHA256]-----+


    \$ ssh-copy-id -i ~/.ssh/id_rsa username@host
\end{alltt}
Authorization via asymmetric cryptography. Two keys are generate a public and a secret one.
The public key is, as the name suggests, public and everyone could read it.
The client encodes his messages with the private key; the receivers could validate the authenticity of those messages using the public key.

This is one of the safest methods, but it's not viable as we need to distribute in some way the private key to
trusted users.

\subsubsection{OAuth2}
Provide an access token at each client, which they could use to validate their
identity at each API request.  This token could be either valid, expired,
revoked or invalid.

\begin{alltt}
    \$ curl -v --header 'Authorization: Bearer 1234' http://localhost:8080/api

    > GET / HTTP/1.1
    > Host: localhost:8080
    > User-Agent: curl/7.72.0
    > Accept: */*
    > Authorization: Bearer 1234
    ...
\end{alltt}

The OAuth2 protocol provides a secure and standardized way for creating and exchanging those token between client and server.


%==============================================================================
\section{OAuth2 Protocol}
\subsection{What is OAuth2?}
Oauth 2.0 is an authorization framework that enables a third-party application
to obtain limited access to an HTTP service either on behalf of a resource
owner.
\subsection{Obtain an access token}

\begin{enumerate}
    \item
        Redirect to the authorization provider.
        \begin{alltt}
    http://google.apis.com?response_type=code\&client_id...
        \end{alltt}

    \item
        If the authorization is successful, the oauth server will redirect to \lstinline{redirect_uri} passing a \lstinline{code}
        as GET parameter. Otherwise \lstinline{error} contains the reason why the authorization was not successful.
        \begin{alltt}
    POST /oauth/token HTTP/1.1
    Host: authorization-server.com

    grant_type=authorization_code
    &code=xxxxxxxxxxx
    &redirect_uri=https://example-app.com/redirect
    &client_id=xxxxxxxxxx
    &client_secret=xxxxxxxxxx
        \end{alltt}

        \textit{If an authorization code is used more than once, the authorization server must deny the subsequent request.}

    \item
        The client exchanges the \lstinline{code}, called also "grant token", with the server to obtain an
        \\
        \lstinline{access\_token}.
    \item The server returns the access token with additional informations, such
        as expire date and JWT.
    \item
        The client uses the access token for APIs requests.
\end{enumerate}

\begin{figure}[h]
    \centering
    \includegraphics[width=.5\textwidth]{authorization-code.png}
\end{figure}
\subsection{Revoke an access token}
Something something

%==============================================================================
\section{SAML: Security Assertion Markup Language}
% Confronto con oauth2
Unlike OAuth, this protocol deals with both authentication and
authorization.

\subsection{Overview}
Uses already existing technologies:
\begin{itemize}
    \item SOAP
    \item XML Schema
    \item HTTP
    \item XML Signature, for encryption and message validation
\end{itemize}

\subsection{Protocol}
SAML protocol describes how SAML elements are packaged with SAML requests
and responses elements.

The most important saml protocol is called "\textit{query}", a service provider
makes a query directly
\subsubsection{SOAP}
The SOAP specification defines the messaging framework, which consists of:
% https://en.wikipedia.org/wiki/SOAP#Specification
\begin{itemize}
    \item SOAP processing model,
    \item SOAP extensibility model
    \item SOAP underlying protocol binding framework
    \item SOAP message construct
\end{itemize}

\subsection{Security}
The standard requires TML v1.0+ for transport layer security, XML signature
and encryption for message-level security.


%==============================================================================
\section{Comparing SAML and OAuth2}
SAML protocol provides authorization and authentication, on the other hand,
OAuth2 is an authorization protocol, therefore is usually associated with OpenID
to provide authenticaiton too.

SAML uses an XML based protocol to call functions after authentications, Oauth2
uses http redirects.




%==============================================================================
\section{SSO with OpenID}
\subsection{Second problem}
We want to delegate the process of authentication of username and password
to an external service, then if the user is registered in our platform we
allow him in.

\subsection{JWT}
JWT is an internet standard for creating JSON based access tokens,
that assert some number of claims in the token itself, so that it is
completely stateless. (system?)

If i give a jwt to a completely different service that has no access to the
database, it will be able to authenticate that guy.
We can do that with encryption: JWT is composed by 3 parts: header, data and a
signature.

The data can not be deliberately modified, with the checksum, only the server
could verify if the token is correct or it has been altered.

With symmetric encryption the server can lock and unlock the token.
Asymmetric private key, can encrypt with a key and validate with another key.

The validation is public, but the generation is private.

% Session based AUTH
% using session id, comports an extra database hit at each request.

% Comparison with session based authrentication
% JWT was invented to solve certain problems
% JWT has it's own problems
the key to check the token should be shared between all the servers.
But once it's stolen we can't do anything about it.

If one stole the token it can authenticate to every service and you can not
retrieve it, because it has no database behind it.

One solution is to make short lived the token, it's not easy to steal them
because it's ssl, and xss has to be well crafted.

Sessions could be made short lived, and force the user to logout every X
minutes, (sometimes it's a bad user experience).

Refresh tokens are exactly like session.
RT are JWT stored in the database. Usually refresh token don't have expiery
date, use access token to make every request and use refresh token in case the
former is expired.
RefreshToken should be stored securely to prevent XSS and CSRF.

With refreshtoken we should hit the database because it's required to verify
that it should't be revoked, expired, blacklisted or something else.

With this improvement we hit the db only once in 15 mins.

In a 0 thrust architecture, it's really rare that symmetric encryption is used
to crete JWTs, because if just one server is hacked, then all the encryption
mechanism is corrupted.

By only deleting the refresh token from the database, you are not able to
logout immediately.

% refresh-token
% asymmetric JWT
JWT are transmitted encoded, as a list of base64 strings, catenated with a dot.
JWT itself is not encrypted, it's signed.

% pros and cons of JWT
Pros:
- stateless
- great for api
- secure: everything encrypted in the token, very hard to break unless it's
used a very weak private key.
- carry useful and trusted information
- rendering pages in frontend without relying on the server.
- can store info that drive UX
- no need for a centralized database.

Cons:
- Sharing secrets in a microservice architecture.
- key management, where to put public key, how to know if it's valid. Deprecate key.
- very tricky to consume correctly.
- storage of refresh tokens.
- token revocation and control. you cannot revoke a jwt, it's staeless.
- insecure implementation of library (e.g. no algorithm), without any algorithm
anyone can create tokens.


\subsection{JWS e JWE}
Token could be signed, encrypted or both.

\subsection{JWS Validation}
Verify the SHA256 signature

\begin{thebibliography}{9}
    \bibitem{google api dev}
    Using OAuth 2.0 to Access Gooogle APIs
    \\
    \texttt{https://developers.google.com/identity/protocols/oauth2}

    \bibitem{Api Keys vs Oauth}
    API Keys vs OAuth Tokens vs JSON Web Tokens
    \\
    \texttt{https://zapier.com/engineering/apikey-oauth-jwt/}

\end{thebibliography}

\newpage
\end{document}

