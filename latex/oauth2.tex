%!TEX program = xelatex
% rubber: set program xelatex
% vim: tw=80: colorcolumn=80: spell
\documentclass[11pt]{style}

\usepackage{alltt}

\setcounter{tocdepth}{2} % Show only sections in table of contents

\title{OAuth2}

\def\relator{Poggi Agostino}

\author{Corradi Alessandro}

\graphicspath{{./res/}}

\begin{document}
\maketitle{}
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

% Document sections
%[nextsection]

%==============================================================================
\section{Prelude}
\subsection{What you will find in this paper}
The goal of this document is to explain how does the OAuth2 protocol work and
how it can be implemented and used within a webserver.

Further down we will see the strength and weaknesses of this protocol and when
it's best adopt this industry standard, where it's adopted and what are it's use
cases.

We will see what OpenID connect and the meaning of Identity Provider, Single SignOn
and JWT.
\subsection{Reading target}
This paper is suited for people who are new to authentication protocols, want to
integrate Oauth2 with their webserver, or want to know in depth how JWT and
OpenID works.

\section{Introduction}
In the early days everything was easier, if you wanted to grant access to your
private data to a third party application, you just have to give them your
username and password to it, and presto! The application can freely access your
account without any restrictions!

But, as we all know, there is no guarantee that an application with keep your
credentials all safe and securely stored, or even worse use them to access more
sensitive informations than necessary.

Today we have agreed to a web standard, to allow services to securely allow
access to third party applications.
This standard is a protocol that takes the name of \textbf{OAuth2}.

Often confused with API
keys\footnote{More on API keys:
\texttt{https://en.wikipedia.org/wiki/Application\_programming\_interface\_key}}
for their similar use and terminology, OAuth2 grants the permission to access
user data to third party application.
The protocol specifies that, instead of you handing them your credentials, an
authentication server forges a key (commonly called \textbf{access token}) that
will be used by clients to perform requests to the user data.

\subsection{Example of OAuth2 use-case}

Let's assume you go on a vacation with your friends, during that vacation you
take a lot of pictures and videos, and your friends do it too.
Each one of you uploads the pictures and videos he took on google cloud, and you
you have a shared folder that weights a few Giga.

At the end of the vacation you want to organize all the pictures and videos
automatically, by adding them labels and name them all in a consistent way, for
example using the place and the date of where the picture was created.

This sounds like a lot of work to do all by hand, but thankfully you find an
online application that does exactly what you need: by combining image
processing and the EXIF tags of each picture or video it can automatically
create labels and rename them. Neat! Now you can delegate all the work with that
application.

Conveniently that application has a button called "Access with google drive"
that when pressed opens up the google login page and asks you if you want to
grant access to the application.

You perform the login with google, accept the permissions and magically the
application starts doing it's work, labeling and renaming images.

% ================================================================================
\subsection{The terminology}
What you have just read is a typical example of the OAuth2 flow, but beofre deep
diving into the implementation and specification of this protocol, let's clear
some terminology.

First and foremost the \textbf{resource owner}, or in other words the one who
actually owns the \textbf{protected resource} or resources.

\begin{itemize}
    \item The \textbf{protected resources}, some form of private data that is
        not publicly accessible, in the example's case the vacation's photo and
        videos.
    \item \textbf{resource owner}: the one who own the protected resource, in
        the example's case you (and your friends).
    \item \textbf{authorization server} the service that knows the resource
        owner's identity, or in other words an application where the resource
        owner has an account. In the example's case it's google.
    \item the \textbf{client} or \textbf{third party application} is the
        applications that requires access to the private resource (photos and
        videos), or access to perform some actions on the private resource
        (rename and assign them some labels).
    \item the \textbf{resource server} is the one that has access to the private
        data, sometimes is the same as the authorization, but as we see in our
        example, it could be different.
        In the example's case it's google drive \footnote{to be clear, google
        has two different services: one for authorization and one for google
        drive}.
\end{itemize}

\subsection{Authentication and Authorization}
Authorization and authentication my sound similar to one another, but they are
two distinct concepts, used in identity and access management:
authentication says who you are, authorization says what actions you can
perform.

OAuth2 is only an authorization protocol, which means that it's only use is for
granting access to protected resources to a client.

Later we could see that it could be extended and used as an authentication
provider with OpenID connect (page \pageref{openid}).

\section{OAuth2 Protocol}
\begin{figure}[h]
    \centering
    \includegraphics[width=.5\textwidth]{authorization-code.png}
\end{figure}

Enough with the chitchat, here comes the fun part, the protocol specifications,
for practical example i will use python, for the simple reason that arguably it
is one of the most readable programming languages out there.

Above you could see the flow of the OAuth2 protocol, it all starts with a
specifically crafted redirect url, that the clients redirects the user to.
The url points to the authorization's server, and it contains parameters in the
form of a querystring. Here is an example:

\begin{lstlisting}
import urllib.request

callback_url = urllib.request.quote('http://localhost:8080')
client_id = 'YOUR-CLIENT-ID-HERE'

redirect_to = (
    'https://www.googleapis.com'
    f'?redirect_uri={callback_url}'
    f'&client_id={client_id}'
     '&grant_type=code'
)
\end{lstlisting}


authorization and resource servers could be a third party service trusted by the
resource server.

\begin{itemize}
    \item  redirect uri, where the client will be redirect after authorization.
    \item  response type: type of the information the client expects to receive
        (most common code, (authorization code))
    \item  scope: permission that the client wants
    \item  consent: authorization server takes the scopes and verifies wether or not
        it want to give client permissions
    \item  client\_id: used to identify the client with the authorization server
    \item  client\_secret: secret password that only client and auth server knows
    \item  auth\_code: short lived code that server sends to the client
    \item access\_token: key the client will use to communicate with the resource server.
\end{itemize}

\subsection{The protocol}
It all starts with a specifically crafted url:
\begin{lstlisting}
https://www.googleapis.com
    ?redirect_uri=http://localhost:3030
    &client_id=
    &scope=email read-contacts
    &grant=code
\end{lstlisting}

In the login prompt, users sees the assertion that will be inserted in the
oauth2 jwt.

OAuth2 flow is always between website A and B, the user has only to consent the
oauth2 request.

It all starts with a specially crafted url, besides the host, it includes extra
information that says what the host should do, they include the registered
application, the redirect uri (once discord is done the authorization the host
will send you there). Response type is for saying that you want a code back, and
scope is the actual data that you want to access.


\subsection{Main entities in authorization protocols}

Today we have agreed to standards, to allow one service to securely allow access
to another.
The first one is oauth (2.0), a security standard where you give an application
permissions to access your data in another application, instead of giving them
username and password, it gives them a key that allows it to access data or do
things on your behalf, on another application.

The steps to grant permissions, or consents are often referred as authorizations
or delegated authorizations.

Once more, you can take back that key whenever you wish.

You have discover an awesome website that tells you a terrible pun every day,
and you want to share it between all your contacts on your mailing list (why
not).
But writing an email to every person in your contact list every day sounds like
a lot of work.

Good thing terrible pun of the day has a feature to email all your friends.
1st you go to your email provider, then you are redirect to your email service.
Firstly it checks if you are logged in, if you are not, it asks you to
authenticate and then it opens a session where it presents the question: "do you
want to give the website access to your contacts?"

Assuming you have not changed your mind you click allow, now you are redirected
to the website and the application can now access your contacts.

Visible and invisible steps to grant consent.
\subsection{Terminology}
Before going in the depths of oauth2 let's map some terminology
(oauth2 protocol explained)

client doen't use the access token, it's jibbrish.
Different ways to achieve the goal, here are a few of them:
\subsubsection{Direct transmission of the user identifier}
Directly send the user id to the server
\begin{alltt}
    \$ curl -v -X POST http://localhost:8080/db_auth '\{"user-id": 1\}'
\end{alltt}
I do not want to sped too much time on this one. It is for sure one of the
fastest
and less secure way to communicate the user identity.

Even someone with some basic knowledge of programming could recognize that by changing the
value of \texttt{user-id}, the request would still be valid and you are recognized as
another user.

\subsubsection{Http Basic Authentication}
Http Basic Auth: each API request is signed with a username and a passwrod, encoded in base64
\begin{alltt}
    \$ curl -u Aladdin:OpenSesamus -v http://localhost:8080/basic

    > GET / HTTP/1.1
    > Host: localhost:8080
    > Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW11cw==
    > User-Agent: curl/7.72.0
    > Accept: */*
    ...
\end{alltt}
Since the credentials are neither hashed nor encrypted, your username and password are always visible by
someone who could read the headers.
Therefore this protocol requires an https channel in order to be somewhat secure.

\subsubsection{API Key}
\begin{alltt}
    \$ curl --header Authorization: Apikey 1234567890abcdef
\end{alltt}
API keys make sense when the users of an API are only developers.

\subsubsection{Public/Private Key}
\begin{alltt}
    \$ ssh-keygen -v
    The key fingerprint is:
    SHA256:tFKUq1HLfJ3Iy6toGec804dKXPgx4P6rrL6Tc4S0wVY ale-cci@vagrant

    The key's randomart image is:
    +---[RSA 3072]----+
    |        ..       |
    |       .E        |
    |     . =++ o .   |
    |      *+=++ o    |
    |     o.*So+.     |
    |      =+oooo     |
    |       O+..o     |
    |      *+*.+ .    |
    |     o=*=*oo     |
    +----[SHA256]-----+


    \$ ssh-copy-id -i ~/.ssh/id_rsa username@host
\end{alltt}
Authorization via asymmetric cryptography. Two keys are generate a public and a secret one.
The public key is, as the name suggests, public and everyone could read it.
The client encodes his messages with the private key; the receivers could validate the authenticity of those messages using the public key.

This is one of the safest methods, but it's not viable as we need to distribute in some way the private key to
trusted users.

\subsubsection{OAuth2}
Provide an access token at each client, which they could use to validate their
identity at each API request.  This token could be either valid, expired,
revoked or invalid.

\begin{lstlisting}[language=bash]
$ curl -v --header 'Authorization: Bearer 1234' \
    http://localhost:8080/api

> GET / HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.72.0
> Accept: */*
> Authorization: Bearer 1234
...
\end{lstlisting}

The OAuth2 protocol provides a secure and standardized way for creating and exchanging those token between client and server.


%==============================================================================
\section{OAuth2 step by step}
\subsection{Obtain an access token}

\begin{enumerate}
    \item
        Redirect to the authorization provider.
        \begin{alltt}
    http://google.apis.com?response_type=code\&client_id...
        \end{alltt}

    \item
        If the authorization is successful, the oauth server will redirect to \lstinline{redirect_uri} passing a \lstinline{code}
        as GET parameter. Otherwise \lstinline{error} contains the reason why the authorization was not successful.
        \begin{alltt}
    POST /oauth/token HTTP/1.1
    Host: authorization-server.com

    grant_type=authorization_code
    &code=xxxxxxxxxxx
    &redirect_uri=https://example-app.com/redirect
    &client_id=xxxxxxxxxx
    &client_secret=xxxxxxxxxx
        \end{alltt}

        \textit{If an authorization code is used more than once, the authorization server must deny the subsequent request.}

    \item
        The client exchanges the \lstinline{code}, called also "grant token", with the server to obtain an
        \\
        \lstinline{access\_token}.
    \item The server returns the access token with additional informations, such
        as expire date and JWT.
    \item
        The client uses the access token for APIs requests.
\end{enumerate}

\subsection{Revoke an access token}
By requirements, an OAuth2 authentication server must expose an endpoint for
revoking the validity of a particular token.

In case the authentication is performed via JWT (see page \pageref{jwt})
Something something

%==============================================================================
\subsection{Protocol Vulnerabilities}
\subsubsection{PKCE (Proof Key for Code Exchange)}
Public applications, such as desktop and mobile apps, are unable to securely
store credentials, in our case, the client secret.

For this particular reason the grant type "authorization" has been created, so
that the step after the authorization that exchanges the code and the secret
with the authorization code is skipped, so the authorization code is immediately
returned.

This particular sequence of events opens up a vulnerability:
when the access token is returned by the authorization response, malicious apps
running alongside our OAuth2 client are able to read it, and therefore use it as
our application would.

PKCE is a superset feature for OAuth2, idealized for preventing this kind of
attack, called "authorization code interception".

OAuth2.1 specification will mandate that all implementation of the authorization
grant type use PKCE.

%==============================================================================
\section{OpenID connect}
\label{openid}

oauth2.0 is designed only for authorization and granting access to data and
feature from one application to another.
OAuth is like giving an application a key, that doesn't tell anything about who
you are.
OIDC is a thin layer that sits on top of Oauth2.0 that add functionality around
login and profile information about the person who is logged in.
Instead of a key, openid is like giving a person a badge. A badge not only gives
permission but also some basic information of who your are.

OIDC enstablish a client to perform a login session.
When an authorization server supports oidc it referred as an identity provider,
since it provides information about the resource owner back to the client.

OpenID connect, enables scenarios where one login can be shared among multiple
applications. It is also known as single sign on.
For example an application can support SSO with social networking services (i.e.
facebook or twitter) so that a user can use a login that he already has and it's
comfortable using it.

Example with ATM. atm is the client and it communicates with the bank. The bank
card is the token issued by the bank. Not only gives access to the atm to your
bank account, but holds some basic information about you, when the card expires
and why you are.
ATM cannot work without the infrastructure of the bank.

On top of oauth, a specific scope of openid is used. The authorization server
goes to all the steps listed before and issues the client an authorization code
via the client's browser.
The key difference is that the client receives both an access token and an id
token.

ID token is a specifically formatted token (JWT). Client can extract your user
id, your email, when you logged in, when it expires, and it can tell if anyone
has tried to tamper with the jwt.

Fields contained in the jwt are called claims.
There is also a standard way that a client can ask additional information from the
authorization server, such as the email address.
%==============================================================================
\section{JWT}
\label{jwt}
\subsection{JWT}
JWT is an internet standard for creating JSON based access tokens. It asserts
some number of claims in the token itself, so that authentication protocols that
uses it can be considered completely stateless.

In other words, if i give a JWT to a completely different service
it is completely able to verify and authenticate the request, even without
database access.

The key concept behind JWT is encryption, it could be symmetric or asymmetric.
With that said, the latter one is preferred, for reasons that i will explain
later.

In a zero thrust architecture, it is really rare that symmetric encryption is
used to create JWTs. If just one server is hacked, then all the encryption in
use is invalidated, and unusable.

JWT are composed by three  parts:

\begin{enumerate}
    \item Header: contains expiration, when it was created, encryption
        algorithm, etc.
    \item Data: data contained in the jwt.
    \item Signature: encrypted checksum obtained combining header and data.
\end{enumerate}

The data cannot be deliberately modified, thanks to the signature, the server
could easily verify if the token is valid or it has been altered.

JWT created with an asymmetric key, can be generated by one server and verified
by everyone thanks to public keys.

\subsection{Access tokens}
Since we are able to trust JWTs  without the use of a database, they offer the
main advantage to not issue database calls to verify the user identity.


Using JWTs instead of cookies for authentications grants the main advantage to
not issue a database, but as they sail "with great power comes great
responsibility", in fact if the token is stolen by someone, you cannot do
anything about it.

Since it is a completely stateless protocol, using JWT as is, there is no way
you can revoke access to the token. No database calls means that there is
nowhere to store that JWT is been revoked.

It is true that it is not easy to steal them, because OAuth2 protocol specifies
that all interactions between client and server are made using SSL protocol, but
it is not impossible.

One workaround to this problem is to make JWTs expire in a short lapse of time,
usually 15 minutes to an hour, then force clients either to re-authenticate or
provide them an extra token (\textit{refresh\_token}), used to re-claim
authentication on their behalf.

Refresh tokens are exactly like session: JWTs stored in the database, with a
long or usually without expiry date.
They should securely stored, in order to prevent XSS and CSRF attacks.

Even with refresh token we have the big advantage to query the database
approximately once each 15 minutes per user.

With that said, it still lies the problem that there is no easy way to revoke a
token. Even if a refresh token is deleted from the database, it's corrispettive
access token is still usable until expiry.

\subsection{Pros and Cons of JWTs}
\subsubsection{Pros:}
\begin{itemize}
    \item Stateless
    \item great for api
    \item secure
    \item carry useful and trusted information
    \item can store information that can drive UX without backend interaction.
    \item No need for a centralized database.
\end{itemize}
\subsubsection{Cons:}
\begin{itemize}
    \item sharing secrets in a microservice architecture.
    \item Key management: where to put public key; how to kow if it's valid and
        deprecated keys.
    \item very tricky to consume correctly
    \item careful storage of refresh token
    \item Impossibility to revoke tokens
    \item Insecure implementation libraries (no algorithm)
\end{itemize}

\subsection{JWS e JWE}
Token could be signed, encrypted or both.

\subsection{JWS Validation}
Verify the SHA256 signature

\section{Dissertation Acknowledgments}
\begin{itemize}
    \item CED MaxMara
\end{itemize}

\begin{thebibliography}{9}
    \bibitem{google api dev}
    Using OAuth 2.0 to Access Gooogle APIs
    \\
    \texttt{https://developers.google.com/identity/protocols/oauth2}

    \bibitem{Api Keys vs Oauth}
    API Keys vs OAuth Tokens vs JSON Web Tokens
    \\
    \texttt{https://zapier.com/engineering/apikey-oauth-jwt/}

\end{thebibliography}

\newpage
\end{document}

